<refentry id="cairo_copy">
  <refmeta>
    <refentrytitle>cairo_copy</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv>
    <refname>cairo_copy</refname>
    <refpurpose>copy contents from one <link linkend="cairo_t">cairo_t</link> to another</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <programlisting>
void cairo_copy (<link linkend="cairo_t">cairo_t</link> *dest, <link linkend="cairo_t">cairo_t</link> *src)</programlisting>
    <variablelist role="params">
      <varlistentry>
        <term><parameter>dest</parameter> :</term>
        <listitem>
          <simpara>an allocated <link linkend="cairo_t">cairo_t</link></simpara>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><parameter>src</parameter> :</term>
        <listitem>
          <simpara><link linkend="cairo_t">cairo_t</link> to copy</simpara>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsynopsisdiv>
  <refsect1>
    <title>Description</title>
    <para>
      <indexterm>
        <primary>functions</primary>
        <secondary>cairo_copy</secondary>
      </indexterm>
      <indexterm>
        <primary/>
      </indexterm>
      This function copies all state information from src to dest. That includes not yet drawn paths and font information.
    </para>
    <para>
The new <link linkend="cairo_t">cairo_t</link> will become owner of the target and clip surfaces by incrementing their refcount. But the surfaces will not be copied, that means operations on either src or dest will be painted onto the same surface.
    </para>
    <para>
    Note that saved states on the stack can only be restored once. So if you have unclosed calls to <link linkend="cairo_save">cairo_save</link> before copying, calling <link linkend="cairo_restore">cairo_restore</link> on both, src and dest is invalid.
    </para>
  </refsect1>
  <refsect1>
    <title>See also</title>
    <para>
    cairo_clone 
    </para>
  </refsect1>

</refentry>
