dnl
dnl These are the facilities for enable/disabling various features,
dnl and for collecting CFLAGS/LIBS and generating per feature .pc
dnl files, assembling list of source files to compile, and creating
dnl cairo-features.h and other generated files.
dnl

dnl ===========================================================================

dnl
dnl Define a macro to enable features
dnl  - Macro: _CAIRO_ENABLE (ID, NAME, WHAT, DEFAULT, COMMANDS)
dnl
dnl where:
dnl
dnl	ID is the sub-namespace in function names, eg. "ft" for cairo_ft_...
dnl	NAME is the human-readable name of the feature, eg. "FreeType font"
dnl	WHAT is the type of feature:
dnl		"surface" for surface backends
dnl		"font" for font backends
dnl		"functions" for set of functions
dnl		"" for private configurations
dnl	DEFAULT is the default state of the feature:
dnl		"no" for experimental backends, eg. your favorite new backend
dnl		"yes" for mandatory backends, eg. png
dnl		"auto" for other supported backends, eg. xlib
dnl	COMMANDS are run to check whether the feature can be enabled.  Their
dnl		result may be cached, so user should not count on them being run.
dnl		They should set use_$(ID) to something other than yes if the
dnl		feature cannot be built, eg. "no (requires SomeThing)".  It then
dnl		should also set $(ID)_REQUIRES/CFLAGS/LIBS/...
dnl		appropriately.  Look at the macro definition for more details,
dnl		or ask if in doubt.
dnl
AC_DEFUN([_CAIRO_ENABLE],
[
	dnl Sanity check ID
	m4_if(
		[$1],
		m4_tolower(AS_TR_SH([$1])),
		,
		[m4_fatal([invalid feature name `$1'])]
	)
	m4_define([cr_feature], [$1])
	m4_define([cr_feature_name], m4_normalize(m4_expand([$2])))
	m4_define([cr_feature_what], m4_normalize(m4_expand([$3])))
	m4_define([cr_feature_default], m4_normalize(m4_expand([$4])))
	m4_define([cr_feature_commands], [$5])
	m4_define([cr_feature_commands_len], m4_len([$5]))

	m4_define([cr_feature_arg], m4_translit([$1],[_],[-]))

	AC_ARG_ENABLE(cr_feature_arg,
		      AS_HELP_STRING([--enable-]cr_feature_arg[=@<:@no/auto/yes@:>@],
				     [Enable cairo's ]cr_feature_name[ feature @<:@default=]cr_feature_default[@:>@]),
		      enable_$1=$enableval, enable_$1=cr_feature_default)
	case $enable_$1 in
	no)
		use_$1="no (disabled, use --enable-cr_feature_arg to enable)"
	;;
	yes|auto)
		dnl Cache invalidating:
		dnl
		dnl To be extremely user-friendly, we discard cache results if
		dnl any of the following conditions happens:
		dnl
		dnl   - Set of cached variables changes
		dnl     (XXX should also do if the default value of such
		dnl     variables changes.  Argh...)
		dnl
		dnl   - Length of the COMMANDS string changes!
		dnl     (This is much more friendly to the cache than caching
		dnl     the commands string itself.  Note that this still does
		dnl     not catch all valid cases where we should be
		dnl     invalidting.  For example if COMMANDS uses
		dnl     variables/macros defined outside, we don't detect changes
		dnl     in those variables.  Also doesn't detect in-place
		dnl     modifications like bumping verson numbers.
		dnl     Just modify COMMANDS in an obvious way to force recheck.
		dnl     Hashing sounds a bit too harsh to do here...)
		dnl
		dnl  - If feature is requested and cached results for enabling
		dnl    feature is no.  We are going to terminate with an error
		dnl    if this happens anyway, so we can be more friendly by
		dnl    assuming that user installed some missing pieces since
		dnl    last time and so we recheck.  Although even in that
		dnl    case other cached values probably get in the way...
		dnl
		AS_IF([test "x$cairo_cv_[]$1[]_cache_commands_len" != "x[]cr_feature_commands_len" -o \
			    "x$cairo_cv_[]$1[]_cache_vars" != "x[]CAIRO_FEATURE_VARS"],
		      [unset cairo_cv_[]$1[]_use])
		AS_IF([test "x$enable_$1" = xyes -a "x$cairo_cv_[]$1[]_use" != xyes],
		      [unset cairo_cv_[]$1[]_use])

		AC_CACHE_CHECK([for cairo's ]cr_feature_name[ feature], cairo_cv_[]$1[]_use,
		[
			echo
			use_[]$1=yes
			CAIRO_FEATURE_VARS_FOREACH(cr_var, [cr_feature[_]cr_var[=$ac_env_]cr_feature[_]cr_var[_value]
			])
			cr_feature_commands
			cairo_cv_[]$1[]_use=$use_[]$1
			cairo_cv_[]$1[]_cache_vars="CAIRO_FEATURE_VARS"
			cairo_cv_[]$1[]_cache_commands_len="cr_feature_commands_len"
			CAIRO_FEATURE_VARS_FOREACH([cr_var], [[cairo_cv_]cr_feature[_]cr_var[=$]cr_feature[_]cr_var
			])
			AC_MSG_CHECKING([whether cairo's ]cr_feature_name[ feature could be enabled])
		])

		use_[]$1=$cairo_cv_[]$1[]_use

		AS_IF([test "x$enable_$1" = "xyes" -a "x$use_$1" != xyes],
		[
			AC_MSG_ERROR([requested ]cr_feature_name[ feature could not be enabled])
		])
	;;
	*)
		AC_MSG_ERROR([invalid argument passed to --enable-]cr_feature_arg[: `$use_$1', should be one of @<:@no/auto/yes@:>@])
	;;
	esac

	AS_IF([test "x$use_$1" = "xyes"],
	[
		CAIRO_FEATURE_VARS_FOREACH([cr_var], [cr_feature[_]cr_var[=$cairo_cv_]cr_feature[_]cr_var
		])
	],[
		dnl If not enabled, empty the vars so no one accidentally uses them.
		CAIRO_FEATURE_VARS_FOREACH([cr_var], [cr_feature[_]cr_var[=$cairo_cv_]cr_feature[_]cr_var
		])
	])


	_CAIRO_FEATURE_HOOKS(cr_feature, cr_feature_name, cr_feature_default, cr_feature_what)
])


dnl ===========================================================================

dnl
dnl CAIRO_FEATURE_VARS_REGISTER(VARS, INITIAL-VALUE=[])
dnl
dnl Registers variables to be collected from feature-enabling code segments.
dnl VARS should be a whitespace-separate list of variable names.
dnl
dnl XXX Should be able to set default value
dnl
dnl XXX Set separator.  Also, prepend/append setting
dnl
dnl XXX An aggregate of the values from all enabled features is collected in
dnl variables named as VARS but prefixed with CAIRO_.
dnl
AC_DEFUN([CAIRO_FEATURE_VARS_REGISTER],
[
	m4_foreach_w([cr_var], [$1],
		     [m4_append_uniq([CAIRO_FEATURE_VARS], cr_var, [ ],,
				     [m4_fatal([Feature variable `]cr_var[' already registered])])])
	m4_foreach_w([cr_var], [$1], [[CAIRO_]cr_var[="$2"]
	])
	m4_foreach_w([cr_var], [$1], [m4_pattern_allow([CAIRO_]cr_var)])
])

AC_DEFUN([CAIRO_FEATURE_VARS_FOREACH],
[
	m4_foreach_w([$1], m4_expand(CAIRO_FEATURE_VARS), [$2])
])


dnl ===========================================================================

AC_DEFUN([CAIRO_FEATURE_IF_ENABLED],
[
	AS_IF([test "x$use_]m4_default([$1], cr_feature)[" = xyes], [$2], [$3])
])

m4_define([_CAIRO_FEATURE_HOOK_MATCH],
[
	m4_case([$1],
		[*],	[$3],
		[$2],	[$3],
		[!$2],	,
			[m4_bmatch([$1], [^!], [$3])])
])

m4_define([_CAIRO_FEATURE_HOOKS])

dnl
dnl CAIRO_FEATURE_HOOK_REGISTER(DEFAULT, WHAT, COMMANDS)
dnl
dnl	DEFAULT is the default value of features to match
dnl	WHAT is the type of features to match
dnl	COMMANDS is commands to run for matched features.
dnl
dnl Runs COMMANDS for features matching DEFAULT and WHAT.  Hooks are run for
dnl each feature in the order they are added.
dnl
dnl DEFAULT and WHAT are matched like this:
dnl	[*]	matches all values
dnl	[val]	matches [val]
dnl	[!val]	matches anything other than [val]
dnl
dnl The following macros can be used in COMMANDS:
dnl
dnl	cr_feature expands to the feature id, eg "ft"
dnl	cr_feature_name	expands to the human-readable name of the feature, eg. "FreeType font"
dnl	cr_feature_default expands to the default state of the feature:
dnl		"no" for experimental backends, eg. your favorite new backend
dnl		"yes" for mandatory backends, eg. png
dnl		"auto" for other supported backends, eg. xlib
dnl	cr_what expands to the type of feature:
dnl		"surface" for surface backends
dnl		"font" for font backends
dnl		"functions" for set of functions
dnl		"" for private configurations
dnl
dnl These four values are also set as $1 to $4.  To know if feature was
dnl enabled use CAIRO_FEATURE_IF_ENABLED:
dnl
dnl	CAIRO_FEATURE_IF_ENABLED($1, [IF-ENABLED], [IF-DISABLED])
dnl
dnl or compare $use_$1 to string "yes".  As in:
dnl
dnl	AS_IF([test "x$use_$1" = "xyes"], [IF-ENABLED], [IF-DISABLED])
dnl
AC_DEFUN([CAIRO_FEATURE_HOOK_REGISTER],
[
	m4_append([_CAIRO_FEATURE_HOOKS],
	[
		_CAIRO_FEATURE_HOOK_MATCH(m4_expand([$1]), cr_feature_default,
		[_CAIRO_FEATURE_HOOK_MATCH(m4_expand([$2]), cr_feature_what,
		 [$3]
		)])
	], m4_newline)
])



dnl ===========================================================================
dnl
dnl Cairo-specific configuration facilities
dnl
dnl ===========================================================================



dnl
dnl Define macros to enable various features.
dnl  - Macro: CAIRO_ENABLE_* (ID, NAME, DEFAULT, COMMANDS)
dnl
dnl where:
dnl
dnl	ID is the feature id, eg. "ft" for cairo_ft_...
dnl	NAME is the human-readable name of the feature, eg. "FreeType"
dnl	DEFAULT is the default state of the feature:
dnl		"no" for experimental backends, eg. your favorite new backend
dnl		"yes" for mandatory backends, eg. png
dnl		"auto" for other supported backends, eg. xlib
dnl	COMMANDS are run to check whether the feature can be enabled.  Their
dnl		result may be cached, so user should not count on them being run.
dnl		They should set use_$(ID) to something other than yes if the
dnl		feature cannot be built, eg. "no (requires SomeThing)".  It then
dnl		should also set $(ID)_REQUIRES/CFLAGS/LIBS/...
dnl		appropriately.  Look at the macro definition for more details,
dnl		or ask if in doubt.
dnl

AC_DEFUN([CAIRO_ENABLE],
	[_CAIRO_ENABLE([$1],	[$2],			,		[$3],[$4])])

AC_DEFUN([CAIRO_ENABLE_SURFACE_BACKEND],
	[_CAIRO_ENABLE([$1],	[$2 surface backend],	surface,	[$3],[$4])])

AC_DEFUN([CAIRO_ENABLE_FONT_BACKEND],
	[_CAIRO_ENABLE([$1],	[$2 font backend],	font,	  	[$3],[$4])])

AC_DEFUN([CAIRO_ENABLE_FUNCTIONS],
	[_CAIRO_ENABLE([$1],	[$2 functions],		functions,	[$3],[$4])])


dnl
dnl Define cr_feature_tag ala other cr_feature_* macros
dnl Expands to CAIRO_HAS_FEATURE_ID
dnl
m4_define([_CAIRO_BUILD_FEATURE_TAG_NORMALIZED],
	[CAIRO_HAS_[$1]m4_bmatch([$1],[$2$],,[$2])])
m4_define([_CAIRO_BUILD_FEATURE_TAG],
	[_CAIRO_BUILD_FEATURE_TAG_NORMALIZED(AS_TR_CPP([$1]),AS_TR_CPP(m4_ifval([$2],[ $2])))])
m4_define([cr_feature_tag],
	[_CAIRO_BUILD_FEATURE_TAG(cr_feature,cr_feature_what)])

dnl Allow feature tags in the output
m4_pattern_allow(^CAIRO_HAS_)



dnl ===========================================================================
dnl
dnl Hooks
dnl
dnl ===========================================================================


dnl ===========================================================================
dnl
dnl Automake conditionals for all features
dnl
CAIRO_FEATURE_HOOK_REGISTER(*,*,
[
	AM_CONDITIONAL(cr_feature_tag, test "x$use_$1" = xyes)
])


dnl ===========================================================================
dnl
dnl Substitute vars
dnl
AC_SUBST(CAIRO_REQUIRES)
AC_SUBST(CAIRO_BASE)
AC_SUBST(CAIRO_CFLAGS)
AC_SUBST(CAIRO_NONPKGCONFIG_CFLAGS)
AC_SUBST(CAIRO_LIBS)
AC_SUBST(CAIRO_NONPKGCONFIG_LIBS)


dnl ===========================================================================
dnl
dnl Accumulate values for all feature vars
dnl

CAIRO_FEATURE_HOOK_REGISTER(*,*,
[
	CAIRO_FEATURE_IF_ENABLED($1,
	[
		CAIRO_FEATURE_VARS_FOREACH([cr_var], [[test -n "$]cr_feature[_]cr_var[" && CAIRO_]cr_var[="$]cr_feature[_]cr_var[ $CAIRO_]cr_var["]
		])
	])
])


dnl ===========================================================================
dnl
dnl Generate {src,boilerplate}/Makefile.{am,win32}.config
dnl

dnl Accumulators
m4_pattern_allow(^CAIRO_CONFIG_AMAKE$)
CAIRO_CONFIG_AMAKE='# Generated by configure.  Do not edit.

include $(top_srcdir)/src/Makefile.sources

enabled_cairo_pkgconf = cairo.pc
enabled_cairo_headers = $(cairo_headers)
enabled_cairo_private = $(cairo_private)
enabled_cairo_sources = $(cairo_sources)
all_cairo_pkgconf =
all_cairo_headers = $(cairo_headers)
all_cairo_private = $(cairo_private)
all_cairo_sources = $(cairo_sources)
supported_cairo_headers = $(cairo_headers)
unsupported_cairo_headers =
'
m4_pattern_allow(^CAIRO_CONFIG_WIN32$)
CAIRO_CONFIG_WIN32=$CAIRO_CONFIG_AMAKE

dnl Generate
CAIRO_CONFIG_COMMANDS([$srcdir/src/Makefile.am.config],
		      [echo "$CAIRO_CONFIG_AMAKE"],
		      [CAIRO_CONFIG_AMAKE='$CAIRO_CONFIG_AMAKE'])
CAIRO_CONFIG_COMMANDS([$srcdir/src/Makefile.win32.config],
		      [echo "$CAIRO_CONFIG_WIN32"],
		      [CAIRO_CONFIG_WIN32='$CAIRO_CONFIG_WIN32'])

dnl Collect list of all supported cairo headers
CAIRO_FEATURE_HOOK_REGISTER(!no,*,
[
	CAIRO_CONFIG_AMAKE=$CAIRO_CONFIG_AMAKE'm4_newline()supported_cairo_headers += $(cairo_$1_headers)'
	CAIRO_CONFIG_WIN32=$CAIRO_CONFIG_WIN32'm4_newline()supported_cairo_headers += $(cairo_$1_headers)'
])

dnl Collect list of all unsupported cairo headers
CAIRO_FEATURE_HOOK_REGISTER(no,*,
[
	CAIRO_CONFIG_AMAKE=$CAIRO_CONFIG_AMAKE'm4_newline()unsupported_cairo_headers += $(cairo_$1_headers)'
	CAIRO_CONFIG_WIN32=$CAIRO_CONFIG_WIN32'm4_newline()unsupported_cairo_headers += $(cairo_$1_headers)'
])

dnl Collect list of all/enabled cairo source files
CAIRO_FEATURE_HOOK_REGISTER(*,*,
[
	CAIRO_CONFIG_AMAKE=$CAIRO_CONFIG_AMAKE'
all_cairo_pkgconf += $(cairo_$1_pkgconf)
all_cairo_headers += $(cairo_$1_headers)
all_cairo_private += $(cairo_$1_private)
all_cairo_sources += $(cairo_$1_sources)
if cr_feature_tag
enabled_cairo_pkgconf += $(cairo_$1_pkgconf)
enabled_cairo_headers += $(cairo_$1_headers)
enabled_cairo_private += $(cairo_$1_private)
enabled_cairo_sources += $(cairo_$1_sources)
endif
'
	CAIRO_CONFIG_WIN32=$CAIRO_CONFIG_WIN32'
all_cairo_pkgconf += $(cairo_$1_pkgconf)
all_cairo_headers += $(cairo_$1_headers)
all_cairo_private += $(cairo_$1_private)
all_cairo_sources += $(cairo_$1_sources)
ifeq ($(cr_feature_tag),1)
enabled_cairo_pkgconf += $(cairo_$1_pkgconf)
enabled_cairo_headers += $(cairo_$1_headers)
enabled_cairo_private += $(cairo_$1_private)
enabled_cairo_sources += $(cairo_$1_sources)
endif
'
])


dnl ===========================================================================
dnl
dnl Generate .pc files
dnl

dnl All .pc files are generated automatically except for this one
AC_CONFIG_FILES([src/cairo.pc])

dnl pkg-config requires, non-pkgconfig cflags and libs, and total cflags and libs
CAIRO_FEATURE_VARS_REGISTER([REQUIRES BASE])
CAIRO_FEATURE_VARS_REGISTER([CFLAGS NONPKGCONFIG_CFLAGS])
CAIRO_FEATURE_VARS_REGISTER([LIBS NONPKGCONFIG_LIBS], [$LIBS])

dnl Generate .pc files for enabled features
CAIRO_FEATURE_HOOK_REGISTER(*,*,
[
	CAIRO_FEATURE_IF_ENABLED($1,
	[
		m4_define([cairo_backend_pc], m4_bpatsubst(src/cairo-$1.pc,_,-))
		AC_CONFIG_FILES(cairo_backend_pc():src/cairo-backend.pc.in,
		[
			$SED -i -e "
			s,@backend_name@,$1,g;
			s,@Backend_Name@,cr_feature_name,g;
			s,@BACKEND_BASE@,$$1_BASE,g;
			s,@BACKEND_REQUIRES@,$$1_REQUIRES,g;
			s%@BACKEND_NONPKGCONFIG_LIBS@%$$1_NONPKGCONFIG_LIBS%g;
			s,@BACKEND_NONPKGCONFIG_CFLAGS@,$$1_NONPKGCONFIG_CFLAGS,g;
			" "]cairo_backend_pc()[" ||
			AC_MSG_ERROR(failed to update ]cairo_backend_pc()[)
		],[
			SED='$SED'
			$1_BASE='$$1_BASE'
			$1_REQUIRES='$$1_REQUIRES'
			$1_NONPKGCONFIG_LIBS='$$1_NONPKGCONFIG_LIBS'
			$1_NONPKGCONFIG_CFLAGS='$$1_NONPKGCONFIG_CFLAGS'
		])
	])
])


dnl ===========================================================================
dnl
dnl Generate src/cairo-features.h src/cairo-supported-features.h
dnl

dnl Collect list of enabled features
CAIRO_FEATURE_HOOK_REGISTER(*,*,
[
	CAIRO_FEATURE_IF_ENABLED($1,
	[
		CAIRO_FEATURES="cr_feature_tag $CAIRO_FEATURES"
	])
])
CAIRO_FEATURE_HOOK_REGISTER(!no,*,
[
	dnl Collect list of all supported features
	CAIRO_SUPPORTED_FEATURES="cr_feature_tag $CAIRO_SUPPORTED_FEATURES"

	dnl Collect list of all supported but disabled features
	CAIRO_FEATURE_IF_ENABLED($1,[],
	[
		CAIRO_NO_FEATURES="cr_feature_tag $CAIRO_NO_FEATURES"
	])

])

dnl Accumulators
m4_pattern_allow(^CAIRO_FEATURES$)
CAIRO_FEATURES=""
m4_pattern_allow(^CAIRO_NO_FEATURES$)
CAIRO_NO_FEATURES=""
m4_pattern_allow(^CAIRO_SUPPORTED_FEATURES$)
CAIRO_SUPPORTED_FEATURES=""

dnl Generate src/cairo-features.h and src/cairo-supported-features.h
CAIRO_CONFIG_COMMANDS([src/cairo-features.h],
[
	echo '/* Generated by configure.  Do not edit. */'
	echo '#ifndef CAIRO_FEATURES_H'
	echo '#define CAIRO_FEATURES_H'
	echo ''
	for FEATURE in $CAIRO_FEATURES; do
		echo "#define $FEATURE 1"
	done | LANG=C sort
	echo ''
	for FEATURE in $CAIRO_NO_FEATURES; do
		echo "/*#undef $FEATURE */"
	done | LANG=C sort
	echo ''
	echo '#endif'
],[
	CAIRO_FEATURES='$CAIRO_FEATURES'
	CAIRO_NO_FEATURES='$CAIRO_NO_FEATURES'
])
CAIRO_CONFIG_COMMANDS([$srcdir/src/cairo-supported-features.h],
[
	echo '/* Generated by configure.  Do not edit. */'
	echo '#ifndef CAIRO_SUPPORTED_FEATURES_H'
	echo '#define CAIRO_SUPPORTED_FEATURES_H'
	echo ''
	echo '/* This is a dummy header, to trick gtk-doc only */'
	echo ''
	for FEATURE in $CAIRO_SUPPORTED_FEATURES; do
		echo "#define $FEATURE 1"
	done
	echo ''
	echo '#endif'
],[
	CAIRO_SUPPORTED_FEATURES='$CAIRO_SUPPORTED_FEATURES'
])


dnl ===========================================================================
dnl
dnl Report
dnl

dnl Accumulator for warning messages
CAIRO_FEATURE_VARS_REGISTER([WARNING_MESSAGE])

dnl Collect warning message for enabled unsupported backends
CAIRO_FEATURE_HOOK_REGISTER(no,*,
[
	CAIRO_FEATURE_IF_ENABLED($1,
	[
		CAIRO_WARNING_MESSAGE="$CAIRO_WARNING_MESSAGE]m4_newline[m4_text_wrap([The ]cr_feature_name[ feature is still under active development and is included in this release only as a preview. It does NOT fully work yet and incompatible changes may yet be made to ]cr_feature_name[ specific API.], [--- ],, 78)
"
	])
])

dnl Collect warning message for disabled recommended backends
CAIRO_FEATURE_HOOK_REGISTER(yes,*,
[
	CAIRO_FEATURE_IF_ENABLED($1,
	[],[
		CAIRO_WARNING_MESSAGE="$CAIRO_WARNING_MESSAGE]m4_newline[m4_text_wrap([It is strictly recommended that you do NOT disable the ]cr_feature_name[ backend.], [+++ ],, 78)
"
	])
])


AC_DEFUN([CAIRO_REPORT],
[
	V="$CAIRO_VERSION_MAJOR.$CAIRO_VERSION_MINOR.$CAIRO_VERSION_MICRO"
	echo ""
	echo "cairo (version $V [[$CAIRO_RELEASE_STATUS]]) will be compiled with the following surface backends:"
	echo "  Image:         yes (always builtin)"
	echo "  Xlib:          $use_xlib"
	echo "  Xlib Xrender:  $use_xlib_xrender"
	echo "  Quartz:        $use_quartz"
	echo "  Quartz-image:  $use_quartz_image"
	echo "  XCB:           $use_xcb"
	echo "  Win32:         $use_win32"
	echo "  OS2:           $use_os2"
	echo "  PostScript:    $use_ps"
	echo "  PDF:           $use_pdf"
	echo "  SVG:           $use_svg"
	echo "  glitz:         $use_glitz"
	echo "  BeOS:          $use_beos"
	echo "  DirectFB:      $use_directfb"
	echo ""
	echo "the following font backends:"
	echo "  User:          yes (always builtin)"
	echo "  FreeType:      $use_ft"
	echo "  Win32:         $use_win32_font"
	echo "  Quartz:        $use_quartz_font"
	echo ""
	echo "the following features:"
	echo "  PNG functions: $use_png"
	echo ""
	echo "and the following debug options:"
	echo "  gcov support:  $use_gcov"
	echo "  test surfaces: $use_test_surfaces"
	echo "  ps testing:    $test_ps"
	echo "  pdf testing:   $test_pdf"
	echo "  svg testing:   $test_svg"
	if test x"$use_win32" = "xyes"; then
		echo "  win32 printing testing:    $test_win32_printing"
	fi
	echo ""
	echo "using CFLAGS:"
	echo $CAIRO_CFLAGS
	echo ""

	if test x"$use_ft"          != "xyes" && \
	   test x"$use_win32_font"  != "xyes" && \
	   test x"$use_quartz_font" != "xyes" ; then

	   AC_MSG_ERROR([Cairo requires at least one font backend.
			  Please install freetype and fontconfig, then try again:
			  http://freetype.org/	http://fontconfig.org/
			])
	fi
	echo "$CAIRO_WARNING_MESSAGE"
])

