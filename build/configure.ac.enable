dnl
dnl These are the facilities for enable/disabling various features,
dnl and for collecting CFLAGS/LIBS and generating per feature .pc
dnl files, assembling list of source files to compile, and creating
dnl cairo-features.h and other generated files.
dnl

dnl ===========================================================================

dnl
dnl Used to force cache invalidation
dnl
m4_define([cr_cache_version], [6])

dnl
dnl Define a macro to enable features
dnl  - Macro: _CAIRO_ENABLE (ID, NAME, WHAT, DEFAULT, COMMANDS)
dnl
dnl where:
dnl
dnl	ID is the sub-namespace in function names, eg. "ft" for cairo_ft_...
dnl	NAME is the human-readable name of the feature, eg. "FreeType font"
dnl	WHAT is the type of feature:
dnl		"surface" for surface backends
dnl		"font" for font backends
dnl		"functions" for set of functions
dnl		"" for private configurations
dnl	DEFAULT is the default state of the feature:
dnl		"no" for experimental features, eg. your favorite new backend
dnl		"yes" for recommended features, eg. png functions
dnl		"auto" for other supported features, eg. xlib surface backend
dnl		"always" for mandatory features (can't be disabled), eg. image surface backend
dnl	COMMANDS are run to check whether the feature can be enabled.  Their
dnl		result may be cached, so user should not count on them being run.
dnl		They should set use_$(ID) to something other than yes if the
dnl		feature cannot be built, eg. "no (requires SomeThing)".  It then
dnl		should also set $(ID)_REQUIRES/CFLAGS/LIBS/...
dnl		appropriately.  Look at the macro definition for more details,
dnl		or ask if in doubt.
dnl
AC_DEFUN([_CAIRO_ENABLE],
[
	dnl Sanity check ID
	m4_if(
		[$1],
		m4_tolower(AS_TR_SH([$1])),
		,
		[m4_fatal([invalid feature name `$1'])]
	)
	m4_pushdef([cr_feature], [$1])dnl
	m4_pushdef([cr_feature_name], m4_normalize([$2]))dnl
	m4_pushdef([cr_feature_what], m4_normalize([$3]))dnl
	m4_pushdef([cr_feature_default], m4_normalize([$4]))dnl
	m4_pushdef([cr_feature_commands], [$5])dnl
	m4_pushdef([cr_feature_commands_len], m4_len([$5]))dnl

	m4_pushdef([cr_feature_arg], m4_translit([$1],_,-))dnl

	dnl Sanity check default
	m4_case(
		cr_feature_default,
		[no],,
		[yes],,
		[auto],,
		[always],,
		[m4_fatal([Invalid default value `]cr_feature_default[' for feature `]cr_feature['])]
	)

	m4_if(cr_feature_default, [always],
	[
		enable_$1=yes
	],[
		AC_ARG_ENABLE(cr_feature_arg,
			      AS_HELP_STRING([--enable-]cr_feature_arg[=@<:@no/auto/yes@:>@],
					     [Enable cairo's ]cr_feature_name[ feature @<:@default=]cr_feature_default[@:>@]),
			      enable_$1=$enableval, enable_$1=cr_feature_default)
	])
	case $enable_$1 in
	no)
		use_$1="no (disabled, use --enable-cr_feature_arg to enable)"
	;;
	yes|auto)
		dnl Cache invalidating:
		dnl
		dnl To be extremely user-friendly, we discard cache results if
		dnl any of the following conditions happens:
		dnl
		dnl   - Global cache version changes
		dnl     This is used to force a cache invalidation for these
		dnl     macros
		dnl
		dnl   - Set of cached variables changes
		dnl     (XXX should also do if the default value of such
		dnl     variables changes.  Argh...)
		dnl
		dnl   - Length of the COMMANDS string changes!
		dnl     (This is much more friendly to the cache than caching
		dnl     the commands string itself.  Note that this still does
		dnl     not catch all valid cases where we should be
		dnl     invalidting.  For example if COMMANDS uses
		dnl     variables/macros defined outside, we don't detect changes
		dnl     in those variables.  Also doesn't detect in-place
		dnl     modifications like bumping verson numbers.
		dnl     Just modify COMMANDS in an obvious way to force recheck.
		dnl     Hashing sounds a bit too harsh to do here...)
		dnl
		dnl  - If feature is requested and cached results for enabling
		dnl    feature is no.  We are going to terminate with an error
		dnl    if this happens anyway, so we can be more friendly by
		dnl    assuming that user installed some missing pieces since
		dnl    last time and so we recheck.  Although even in that
		dnl    case other cached values probably get in the way...
		dnl
		AS_IF([test "x$cairo_cv_[]$1[]_cache_version" != "x[]cr_cache_version" -o \
			    "x$cairo_cv_[]$1[]_cache_commands_len" != "x[]cr_feature_commands_len" -o \
			    "x$cairo_cv_[]$1[]_cache_vars" != "x[]_CAIRO_FEATURE_VARS"],
		      [unset cairo_cv_[]$1[]_use])
		AS_IF([test "x$enable_$1" = xyes -a "x$cairo_cv_[]$1[]_use" != xyes],
		      [unset cairo_cv_[]$1[]_use])

		AC_CACHE_CHECK([for cairo's ]cr_feature_name[ feature], cairo_cv_[]$1[]_use,
		[
			echo
			use_[]$1=yes
			CAIRO_FEATURE_VARS_FOREACH(cr_var, [cr_feature[_]cr_var[=]m4_do([cr_var_default_]cr_var[_value])]m4_newline)
			cr_feature_commands
			cairo_cv_[]$1[]_use=$use_[]$1
			cairo_cv_[]$1[]_cache_vars="_CAIRO_FEATURE_VARS"
			cairo_cv_[]$1[]_cache_commands_len="cr_feature_commands_len"
			cairo_cv_[]$1[]_cache_version="cr_cache_version"
			CAIRO_FEATURE_VARS_FOREACH([cr_var], [[cairo_cv_]cr_feature[_]cr_var[=$]cr_feature[_]cr_var]m4_newline)
			AC_MSG_CHECKING([whether cairo's ]cr_feature_name[ feature could be enabled])
		])

		use_[]$1=$cairo_cv_[]$1[]_use

		AS_IF([test "x$enable_$1" = "xyes" -a "x$use_$1" != xyes],
		[
			AC_MSG_ERROR(
				m4_case(cr_feature_default,
					[always],	[mandatory],
					[yes],		[recommended],
					,		[requested]
				) cr_feature_name[ feature could not be enabled])
		])
	;;
	*)
		AC_MSG_ERROR([invalid argument passed to --enable-]cr_feature_arg[: `$use_$1', should be one of @<:@no/auto/yes@:>@])
	;;
	esac

	AS_IF([test "x$use_$1" = "xyes"],
	[
		CAIRO_FEATURE_VARS_FOREACH([cr_var], [cr_feature[_]cr_var[=$cairo_cv_]cr_feature[_]cr_var]m4_newline)
		CAIRO_ACCUMULATED_FEATURE_VARS_FOREACH([cr_var],
		[
			CAIRO_ACCUMULATE_UNQUOTED_BEFORE(cr_var, [$]cr_feature[_]cr_var)
		])
	],[
		dnl If not enabled, empty the vars so no one accidentally uses them.
		CAIRO_FEATURE_VARS_FOREACH([cr_var], [cr_feature[_]cr_var[=$cairo_cv_]cr_feature[_]cr_var]m4_newline)
	])


	_CAIRO_FEATURE_HOOKS(cr_feature, cr_feature_name, cr_feature_default, cr_feature_what)


	m4_popdef([cr_feature])dnl
	m4_popdef([cr_feature_name])dnl
	m4_popdef([cr_feature_what])dnl
	m4_popdef([cr_feature_default])dnl
	m4_popdef([cr_feature_commands])dnl
	m4_popdef([cr_feature_commands_len])dnl
	m4_popdef([cr_feature_arg])dnl
])


dnl ===========================================================================

m4_define([_CAIRO_FEATURE_VARS])

dnl
dnl CAIRO_FEATURE_VARS_REGISTER(VARS, DEFAULT-VALUE=[])
dnl
dnl Registers variables to be collected from feature-enabling code segments.
dnl VARS should be a whitespace-separate list of variable names.
dnl
dnl DEFAULT-VALUE is m4 macros to set default value of VARS
dnl
AC_DEFUN([CAIRO_FEATURE_VARS_REGISTER],
[
	m4_foreach_w([cr_var], [$1],
		     [m4_append_uniq([_CAIRO_FEATURE_VARS], cr_var, [ ],,
				     [m4_fatal([Feature variable `]cr_var[' already registered])])])
	m4_foreach_w([cr_var], [$1],
	[
		m4_define([cr_var_default_]cr_var[_value], m4_default([$2],[[$ac_env_[]]cr_feature[[]_]]cr_var[[_value]]))
	])
])

dnl
dnl CAIRO_FEATURE_VARS_FOREACH(VAR, COMMANDS)
dnl 
dnl Run COMMANDS for each registered feature variable.
dnl Defines VAR to the variable being processed.
dnl
AC_DEFUN([CAIRO_FEATURE_VARS_FOREACH],
[
	m4_foreach_w([$1], m4_defn([_CAIRO_FEATURE_VARS]), [$2])
])


dnl ===========================================================================

m4_define([_CAIRO_ACCUMULATORS])

m4_define([_CAIRO_ACCUMULATORS_REGISTER],
[
	m4_foreach_w([cr_var], [$1],
		     [m4_append_uniq([_CAIRO_ACCUMULATORS], cr_var, [ ],,
				     [m4_fatal([Accumulator `]cr_var[' already registered])])])dnl
	m4_foreach_w([cr_var], [$1], [m4_define([cr_acc_]cr_var[_sep], [$2])])dnl
	m4_foreach_w([cr_var], [$1], [[CAIRO_]cr_var[=$3]]m4_newline)dnl
	m4_foreach_w([cr_var], [$1], [m4_pattern_allow([CAIRO_]cr_var)])dnl
])

dnl
dnl CAIRO_ACCUMULATORS_REGISTER(VARS, SEPARATOR=[], INITIAL-VALUE=[])
dnl
dnl Registers accumulators.  An accumulator is a shell variable that can
dnl be accumulated to.  The macros take care of adding a SEPARATOR between
dnl accumulated values.
dnl
dnl VARS should be a whitespace-separate list of variable names.  The actual
dnl shell variable resulting for each variable is prefixed with CAIRO_.
dnl
AC_DEFUN([CAIRO_ACCUMULATORS_REGISTER],
[
	_CAIRO_ACCUMULATORS_REGISTER([$1],[$2],['$3'])
])

dnl
dnl Like CAIRO_ACCUMULATORS_REGISTER but INITIAL-VALUE is left unquoted,
dnl so it can reference other shell variables for example.
dnl
AC_DEFUN([CAIRO_ACCUMULATORS_REGISTER_UNQUOTED],
[
	_CAIRO_ACCUMULATORS_REGISTER([$1],[$2],["$3"])
])

m4_define([_CAIRO_ACCUMULATOR_CHECK],
[
        m4_ifdef([cr_acc_$1_sep],,[m4_fatal([Accumulator ]$1[ not defined.])])
])

m4_define([_CAIRO_ACCUMULATE],
[
	_CAIRO_ACCUMULATOR_CHECK([$1])
	m4_ifval([$2], [$3])
])

dnl
dnl CAIRO_ACCUMULATE(VAR, VALUE)
dnl
dnl Appends VALUE to accumulator VAR
dnl
AC_DEFUN([CAIRO_ACCUMULATE],
[
	_CAIRO_ACCUMULATE([$1], [$2], [CAIRO_$1="${CAIRO_$1}]m4_do([cr_acc_$1_sep])["'$2'])
])

dnl
dnl CAIRO_ACCUMULATE(VAR, VALUE)
dnl
dnl Prepends VALUE to accumulator VAR
dnl
AC_DEFUN([CAIRO_ACCUMULATE_BEFORE],
[
	_CAIRO_ACCUMULATE([$1], [$2], [CAIRO_$1='$2'"]m4_do([cr_acc_$1_sep])[${CAIRO_$1}"])
])

m4_define([_CAIRO_ACCUMULATE_UNQUOTED],
[
	_CAIRO_ACCUMULATOR_CHECK([$1])
	m4_ifval([$2], [m4_bmatch([$2],[[$]],[test -n "$2" &&]) $3])
])

dnl
dnl CAIRO_ACCUMULATE_UNQUOTED(VAR, VALUE)
dnl
dnl Like CAIRO_ACCUMULATE but VALUE is left unquoted,
dnl so it can reference other shell variables for example.
dnl
AC_DEFUN([CAIRO_ACCUMULATE_UNQUOTED],
[
	_CAIRO_ACCUMULATE_UNQUOTED([$1], [$2], [CAIRO_$1="${CAIRO_$1}]m4_do([cr_acc_$1_sep])[$2"])
])

dnl
dnl CAIRO_ACCUMULATE_UNQUOTED_BEFORE(VAR, VALUE)
dnl
dnl Like CAIRO_ACCUMULATE_BEFORE but VALUE is left unquoted,
dnl so it can reference other shell variables for example.
dnl
AC_DEFUN([CAIRO_ACCUMULATE_UNQUOTED_BEFORE],
[
	_CAIRO_ACCUMULATE_UNQUOTED([$1], [$2], [CAIRO_$1="$2]m4_do([cr_acc_$1_sep])[${CAIRO_$1}"])
])

dnl
dnl CAIRO_ACCUMULATORS_FOREACH(VAR, COMMANDS)
dnl 
dnl Run COMMANDS for each registered accumulator.
dnl Defines VAR to the accumulator being processed.
dnl
AC_DEFUN([CAIRO_ACCUMULATORS_FOREACH],
[
	m4_foreach_w([$1], m4_defn([_CAIRO_ACCUMULATORS]), [$2])
])


dnl ===========================================================================

m4_define([_CAIRO_ACCUMULATED_FEATURE_VARS])

dnl
dnl CAIRO_ACCUMULATED_FEATURE_VARS_REGISTER(VARS, DEFAULT-VALUE=[], SEPARATOR=[], INITIAL-VALUE=[])
dnl
dnl Defines VARS as feature variables and accumulators.  Also accumulates
dnl (prepending, not appending) feature values for VARS.
dnl
AC_DEFUN([CAIRO_ACCUMULATED_FEATURE_VARS_REGISTER],
[
	m4_foreach_w([cr_var], [$1],
		     [m4_append_uniq([_CAIRO_ACCUMULATED_FEATURE_VARS], cr_var, [ ],,
				     [m4_fatal([Accumulated feature variable `]cr_var[' already registered])])])dnl
	CAIRO_FEATURE_VARS_REGISTER([$1],[$2])dnl
	CAIRO_ACCUMULATORS_REGISTER_UNQUOTED([$1],[$3],[$4])dnl
])

dnl
dnl CAIRO_ACCUMULATED_FEATURE_VARS_FOREACH(VAR, COMMANDS)
dnl 
dnl Run COMMANDS for each registered accumulated feature variable.
dnl Defines VAR to the variable being processed.
dnl
AC_DEFUN([CAIRO_ACCUMULATED_FEATURE_VARS_FOREACH],
[
	m4_foreach_w([$1], m4_defn([_CAIRO_ACCUMULATED_FEATURE_VARS]), [$2])
])

dnl ===========================================================================

dnl
dnl CAIRO_FEATURE_IF_ENABLED(FEATURE=cr_feature, COMMANDS)
dnl
dnl Run COMMANDS if FEATURE is enabled.
dnl
AC_DEFUN([CAIRO_FEATURE_IF_ENABLED],
[
	AS_IF([test "x$use_]m4_default([$1], cr_feature)[" = xyes], [$2], [$3])
])

m4_define([_CAIRO_FEATURE_HOOK_MATCH_SH_BOOL],
[
	m4_case([$1],
		[*],	[$3],
		[no],	[AS_IF([test "x$2" != xyes], [:m4_newline$3])],
		[yes],	[AS_IF([test "x$2" = xyes], [:m4_newline$3])],
			[m4_fatal([Invalid ENABLED value `]$1['])])
])

m4_define([_CAIRO_FEATURE_HOOK_MATCH_M4],
[
	m4_case([$1],
		[*],	[$3],
		[$2],	[$3],
		[!$2],	,
			[m4_bmatch([$1], [^!], [$3])])
])

m4_define([_CAIRO_FEATURE_HOOKS])

dnl
dnl CAIRO_FEATURE_HOOK_REGISTER(ENABLED, DEFAULT, WHAT, COMMANDS)
dnl
dnl	ENABLED is the feature enabledness to match
dnl	DEFAULT is the default value of features to match
dnl	WHAT is the type of features to match
dnl	COMMANDS is commands to run for matched features.
dnl
dnl Runs COMMANDS for features matching ENABLED, DEFAULT, and WHAT.
dnl Hooks are run for each feature in the order they are added.
dnl
dnl DEFAULT and WHAT are matched like this:
dnl	[*]	matches all values
dnl	[val]	matches [val]
dnl	[!val]	matches anything other than [val]
dnl
dnl ENABLED is matched like this:
dnl 	[yes]	matches enabled features
dnl 	[no]	matches disabled features
dnl 	[*]	matches all features
dnl
dnl The following macros can be used in COMMANDS:
dnl
dnl	cr_feature expands to the feature id, eg "ft"
dnl	cr_feature_name	expands to the human-readable name of the feature, eg. "FreeType font"
dnl	cr_feature_default expands to the default state of the feature:
dnl		"no" for experimental features, eg. your favorite new backend
dnl		"yes" for recommended features, eg. png functions
dnl		"auto" for other supported features, eg. xlib surface backend
dnl		"always" for mandatory features (can't be disabled), eg. image surface backend
dnl	cr_what expands to the type of feature:
dnl		"surface" for surface backends
dnl		"font" for font backends
dnl		"functions" for set of functions
dnl		"" for private configurations
dnl
dnl These four values are also set as $1 to $4.  To know if feature was
dnl enabled from within COMMANDS, use CAIRO_FEATURE_IF_ENABLED:
dnl
dnl	CAIRO_FEATURE_IF_ENABLED($1, [IF-ENABLED], [IF-DISABLED])
dnl
dnl or compare $use_$1 to string "yes".  As in:
dnl
dnl	AS_IF([test "x$use_$1" = "xyes"], [IF-ENABLED], [IF-DISABLED])
dnl
AC_DEFUN([CAIRO_FEATURE_HOOK_REGISTER],
[
	m4_append([_CAIRO_FEATURE_HOOKS],
	[
		_CAIRO_FEATURE_HOOK_MATCH_M4([$2], cr_feature_default,
		[_CAIRO_FEATURE_HOOK_MATCH_M4([$3], cr_feature_what,
		 [_CAIRO_FEATURE_HOOK_MATCH_SH_BOOL([$1], [$use_]cr_feature,
		  [$4]
		)])])
	], m4_newline)
])



dnl ===========================================================================
dnl
dnl Cairo-specific configuration facilities
dnl
dnl ===========================================================================



dnl
dnl Define macros to enable various features.
dnl  - Macro: CAIRO_ENABLE_* (ID, NAME, DEFAULT, COMMANDS)
dnl
dnl where:
dnl
dnl	ID is the feature id, eg. "ft" for cairo_ft_...
dnl	NAME is the human-readable name of the feature, eg. "FreeType"
dnl	DEFAULT is the default state of the feature:
dnl		"no" for experimental backends, eg. your favorite new backend
dnl		"yes" for mandatory backends, eg. png
dnl		"auto" for other supported backends, eg. xlib
dnl	COMMANDS are run to check whether the feature can be enabled.  Their
dnl		result may be cached, so user should not count on them being run.
dnl		They should set use_$(ID) to something other than yes if the
dnl		feature cannot be built, eg. "no (requires SomeThing)".  It then
dnl		should also set $(ID)_REQUIRES/CFLAGS/LIBS/...
dnl		appropriately.  Look at the macro definition for more details,
dnl		or ask if in doubt.
dnl

AC_DEFUN([CAIRO_ENABLE],
	[_CAIRO_ENABLE([$1],	[$2],			,		[$3],[$4])])

AC_DEFUN([CAIRO_ENABLE_SURFACE_BACKEND],
	[_CAIRO_ENABLE([$1],	[$2 surface backend],	surface,	[$3],[$4])])

AC_DEFUN([CAIRO_ENABLE_FONT_BACKEND],
	[_CAIRO_ENABLE([$1],	[$2 font backend],	font,	  	[$3],[$4])])

AC_DEFUN([CAIRO_ENABLE_FUNCTIONS],
	[_CAIRO_ENABLE([$1],	[$2 functions],		functions,	[$3],[$4])])


dnl
dnl Define cr_feature_tag ala other cr_feature_* macros
dnl Expands to CAIRO_HAS_FEATURE_ID
dnl
m4_define([_CAIRO_BUILD_FEATURE_TAG_NORMALIZED],
	[CAIRO_HAS_[$1]m4_bmatch([$1],[$2$],,[$2])])
m4_define([_CAIRO_BUILD_FEATURE_TAG],
	[_CAIRO_BUILD_FEATURE_TAG_NORMALIZED(AS_TR_CPP([$1]),AS_TR_CPP(m4_ifval([$2],[ $2])))])
m4_define([cr_feature_tag],
	[_CAIRO_BUILD_FEATURE_TAG(cr_feature,cr_feature_what)])

dnl Allow feature tags in the output
m4_pattern_allow(^CAIRO_HAS_)


dnl
dnl Define cr_feature_pc and friends ala other cr_feature_* macros
dnl
m4_define([cr_feature_pc_modname],
	[[cairo-]m4_translit(cr_feature,_,-)])
m4_define([cr_feature_pc],
	[cr_feature_pc_modname[.pc]])
m4_define([cr_feature_uninstalled_pc],
	[cr_feature_pc_modname[-uninstalled.pc]])


dnl ===========================================================================
dnl
dnl Hooks
dnl
dnl ===========================================================================


dnl ===========================================================================
dnl
dnl Automake conditionals for all features
dnl
CAIRO_FEATURE_HOOK_REGISTER(*,*,*,
[
	AM_CONDITIONAL(cr_feature_tag, test "x$use_$1" = xyes)
])


dnl ===========================================================================
dnl
dnl Generate {src,boilerplate}/Makefile.{am,win32}.config
dnl

dnl Accumulators
dnl	CAIRO_ACCUMULATE(FEATURES, cr_feature_tag)
CAIRO_ACCUMULATORS_REGISTER(CONFIG_AMAKE,m4_newline,[# Generated by configure.  Do not edit.
include $(top_srcdir)/src/Makefile.sources

enabled_cairo_pkgconf = cairo.pc
enabled_cairo_headers = $(cairo_headers)
enabled_cairo_private = $(cairo_private)
enabled_cairo_sources = $(cairo_sources)
all_cairo_pkgconf =
all_cairo_headers = $(cairo_headers)
all_cairo_private = $(cairo_private)
all_cairo_sources = $(cairo_sources)
supported_cairo_headers = $(cairo_headers)
unsupported_cairo_headers =])

CAIRO_ACCUMULATORS_REGISTER_UNQUOTED(CONFIG_WIN32,m4_newline,[$CAIRO_CONFIG_AMAKE])

dnl Generate
CAIRO_CONFIG_COMMANDS([$srcdir/src/Makefile.am.config],
		      [echo "$CAIRO_CONFIG_AMAKE"],
		      [CAIRO_CONFIG_AMAKE='$CAIRO_CONFIG_AMAKE'])
CAIRO_CONFIG_COMMANDS([$srcdir/src/Makefile.win32.config],
		      [echo "$CAIRO_CONFIG_WIN32"],
		      [CAIRO_CONFIG_WIN32='$CAIRO_CONFIG_WIN32'])

dnl Collect list of all supported public cairo headers
CAIRO_FEATURE_HOOK_REGISTER(*,!no,!,
[
	CAIRO_ACCUMULATE(CONFIG_AMAKE, [supported_cairo_headers += $(cairo_$1_headers)])
	CAIRO_ACCUMULATE(CONFIG_WIN32, [supported_cairo_headers += $(cairo_$1_headers)])
])

dnl Collect list of all unsupported public cairo headers
CAIRO_FEATURE_HOOK_REGISTER(*,no,!,
[
	CAIRO_ACCUMULATE(CONFIG_AMAKE, [unsupported_cairo_headers += $(cairo_$1_headers)])
	CAIRO_ACCUMULATE(CONFIG_WIN32, [unsupported_cairo_headers += $(cairo_$1_headers)])
])

dnl Collect list of source files for all/enabled public features
CAIRO_FEATURE_HOOK_REGISTER(*,*,!,
[
	CAIRO_ACCUMULATE(CONFIG_AMAKE, [
all_cairo_headers += $(cairo_$1_headers)
all_cairo_private += $(cairo_$1_private)
all_cairo_sources += $(cairo_$1_sources)
if cr_feature_tag
enabled_cairo_headers += $(cairo_$1_headers)
enabled_cairo_private += $(cairo_$1_private)
enabled_cairo_sources += $(cairo_$1_sources)
endif
])
	CAIRO_ACCUMULATE(CONFIG_WIN32, [
all_cairo_headers += $(cairo_$1_headers)
all_cairo_private += $(cairo_$1_private)
all_cairo_sources += $(cairo_$1_sources)
ifeq ($(cr_feature_tag),1)
enabled_cairo_headers += $(cairo_$1_headers)
enabled_cairo_private += $(cairo_$1_private)
enabled_cairo_sources += $(cairo_$1_sources)
endif
])
])

dnl Collect list of source files for all/enabled private features
CAIRO_FEATURE_HOOK_REGISTER(*,*,,
[
	dnl No public headers for private features
	CAIRO_ACCUMULATE(CONFIG_AMAKE, [
all_cairo_private += $(cairo_$1_private) $(cairo_$1_headers)
all_cairo_sources += $(cairo_$1_sources)
if cr_feature_tag
enabled_cairo_private += $(cairo_$1_private) $(cairo_$1_headers)
enabled_cairo_sources += $(cairo_$1_sources)
endif
])
	CAIRO_ACCUMULATE(CONFIG_WIN32, [
all_cairo_private += $(cairo_$1_private) $(cairo_$1_headers)
all_cairo_sources += $(cairo_$1_sources)
ifeq ($(cr_feature_tag),1)
enabled_cairo_private += $(cairo_$1_private) $(cairo_$1_headers)
enabled_cairo_sources += $(cairo_$1_sources)
endif
])
])


dnl ===========================================================================
dnl
dnl Generate .pc files
dnl

dnl All .pc files are generated automatically except for this one
AC_CONFIG_FILES([src/cairo.pc])
AC_CONFIG_FILES([cairo-uninstalled.pc:src/cairo-uninstalled.pc.in])

dnl pkg-config requires, non-pkgconfig cflags and libs, and total cflags and libs
CAIRO_FEATURE_VARS_REGISTER([BASE],[cairo])
CAIRO_ACCUMULATED_FEATURE_VARS_REGISTER([REQUIRES],,[ ])
CAIRO_ACCUMULATED_FEATURE_VARS_REGISTER([CFLAGS NONPKGCONFIG_CFLAGS],,[ ])
CAIRO_ACCUMULATED_FEATURE_VARS_REGISTER([LIBS NONPKGCONFIG_LIBS],,[ ],[$LIBS])
AC_SUBST(CAIRO_REQUIRES)
AC_SUBST(CAIRO_BASE)
AC_SUBST(CAIRO_CFLAGS)
AC_SUBST(CAIRO_NONPKGCONFIG_CFLAGS)
AC_SUBST(CAIRO_LIBS)
AC_SUBST(CAIRO_NONPKGCONFIG_LIBS)


dnl Generate .pc files for enabled non-builtin public features
CAIRO_FEATURE_HOOK_REGISTER(yes,!always,!,
[
	AC_CONFIG_FILES(src/cr_feature_pc:src/cairo-features.pc.in,
	[
		$SED -i -e "
		s%@FEATURE_PC@%]cr_feature_pc_modname[%g;
		s%@FEATURE_NAME@%]cr_feature_name[%g;
		s%@FEATURE_BASE@%$$1_BASE%g;
		s%@FEATURE_REQUIRES@%$$1_REQUIRES%g;
		s%@FEATURE_NONPKGCONFIG_LIBS@%$$1_NONPKGCONFIG_LIBS%g;
		s%@FEATURE_NONPKGCONFIG_CFLAGS@%$$1_NONPKGCONFIG_CFLAGS%g;
		" "]src/cr_feature_pc[" ||
		AC_MSG_ERROR(failed to update ]src/cr_feature_pc[)
	],[
		SED='$SED'
		$1_BASE='$$1_BASE'
		$1_REQUIRES='$$1_REQUIRES'
		$1_NONPKGCONFIG_LIBS='$$1_NONPKGCONFIG_LIBS'
		$1_NONPKGCONFIG_CFLAGS='$$1_NONPKGCONFIG_CFLAGS'
	])
])

dnl Generate -uninstalled.pc files for enabled non-builtin public features
CAIRO_FEATURE_HOOK_REGISTER(yes,!always,!,
[
	AC_CONFIG_FILES(cr_feature_uninstalled_pc:src/cairo-features-uninstalled.pc.in,
	[
		$SED -i -e "
		s%@FEATURE_PC@%]cr_feature_pc_modname[%g;
		s%@FEATURE_NAME@%]cr_feature_name[%g;
		s%@FEATURE_BASE@%$$1_BASE%g;
		s%@FEATURE_REQUIRES@%$$1_REQUIRES%g;
		s%@FEATURE_NONPKGCONFIG_LIBS@%$$1_NONPKGCONFIG_LIBS%g;
		s%@FEATURE_NONPKGCONFIG_CFLAGS@%$$1_NONPKGCONFIG_CFLAGS%g;
		" "]src/cr_feature_pc[" ||
		AC_MSG_ERROR(failed to update ]src/cr_feature_pc[)
	],[
		SED='$SED'
		$1_BASE='$$1_BASE'
		$1_REQUIRES='$$1_REQUIRES'
		$1_NONPKGCONFIG_LIBS='$$1_NONPKGCONFIG_LIBS'
		$1_NONPKGCONFIG_CFLAGS='$$1_NONPKGCONFIG_CFLAGS'
	])
])

dnl Collect list of .pc files for all/enabled non-builtin public features
CAIRO_FEATURE_HOOK_REGISTER(*,!always,!,
[
	CAIRO_CONFIG_AMAKE=$CAIRO_CONFIG_AMAKE'
all_cairo_pkgconf += cr_feature_pc
if cr_feature_tag
enabled_cairo_pkgconf += cr_feature_pc
endif
'
])


dnl ===========================================================================
dnl
dnl Generate src/cairo-features.h src/cairo-supported-features.h
dnl

dnl Collect list of enabled public features
CAIRO_ACCUMULATORS_REGISTER(FEATURES,[ ])
CAIRO_FEATURE_HOOK_REGISTER(yes,*,!,
[
	CAIRO_ACCUMULATE(FEATURES, cr_feature_tag)
])
dnl Collect list of all supported public features
CAIRO_ACCUMULATORS_REGISTER(SUPPORTED_FEATURES,[ ])
CAIRO_FEATURE_HOOK_REGISTER(*,!no,!,
[
	CAIRO_ACCUMULATE(SUPPORTED_FEATURES, cr_feature_tag)
])
dnl Collect list of all supported disabled public features
CAIRO_ACCUMULATORS_REGISTER(NO_FEATURES,[ ])
CAIRO_FEATURE_HOOK_REGISTER(no,!no,!,
[
	CAIRO_ACCUMULATE(NO_FEATURES, cr_feature_tag)
])

dnl Generate src/cairo-features.h and src/cairo-supported-features.h
CAIRO_CONFIG_COMMANDS([src/cairo-features.h],
[
	echo '/* Generated by configure.  Do not edit. */'
	echo '#ifndef CAIRO_FEATURES_H'
	echo '#define CAIRO_FEATURES_H'
	echo ''
	for FEATURE in $CAIRO_FEATURES; do
		echo "#define $FEATURE 1"
	done | LANG=C sort
	echo ''
	for FEATURE in $CAIRO_NO_FEATURES; do
		echo "/*#undef $FEATURE */"
	done | LANG=C sort
	echo ''
	echo '#endif'
],[
	CAIRO_FEATURES='$CAIRO_FEATURES'
	CAIRO_NO_FEATURES='$CAIRO_NO_FEATURES'
])
CAIRO_CONFIG_COMMANDS([$srcdir/src/cairo-supported-features.h],
[
	echo '/* Generated by configure.  Do not edit. */'
	echo '#ifndef CAIRO_SUPPORTED_FEATURES_H'
	echo '#define CAIRO_SUPPORTED_FEATURES_H'
	echo ''
	echo '/* This is a dummy header, to trick gtk-doc only */'
	echo ''
	for FEATURE in $CAIRO_SUPPORTED_FEATURES; do
		echo "#define $FEATURE 1"
	done
	echo ''
	echo '#endif'
],[
	CAIRO_SUPPORTED_FEATURES='$CAIRO_SUPPORTED_FEATURES'
])

dnl For enabled private features just define them in config.h.  No fanfare!
CAIRO_FEATURE_HOOK_REGISTER(yes,*,,
[
	AC_DEFINE(cr_feature_tag, 1, [Define to 1 to enable cairo's ]cr_feature_name[ feature])
])

dnl ===========================================================================
dnl
dnl Report
dnl

CAIRO_ACCUMULATORS_REGISTER([WARNING_MESSAGE],m4_newline()m4_newline)

dnl Collect warning message for enabled unsupported public features
CAIRO_FEATURE_HOOK_REGISTER(yes,no,!,
[
	CAIRO_ACCUMULATE([WARNING_MESSAGE], m4_text_wrap([The ]cr_feature_name[ feature is still under active development and is included in this release only as a preview. It does NOT fully work yet and incompatible changes may yet be made to ]cr_feature_name[ specific API.], [--- ],, 78))
])

dnl Collect warning message for disabled recommended features
CAIRO_FEATURE_HOOK_REGISTER(no,yes,*,
[
	CAIRO_ACCUMULATE([WARNING_MESSAGE], m4_text_wrap([It is strictly recommended that you do NOT disable the ]cr_feature_name[ feature.], [+++ ],, 78))
])


AC_DEFUN([CAIRO_REPORT],
[
	V="$CAIRO_VERSION_MAJOR.$CAIRO_VERSION_MINOR.$CAIRO_VERSION_MICRO"
	echo ""
	echo "cairo (version $V [[$CAIRO_RELEASE_STATUS]]) will be compiled with the following surface backends:"
	echo "  Image:         yes (always builtin)"
	echo "  Xlib:          $use_xlib"
	echo "  Xlib Xrender:  $use_xlib_xrender"
	echo "  Quartz:        $use_quartz"
	echo "  Quartz-image:  $use_quartz_image"
	echo "  XCB:           $use_xcb"
	echo "  Win32:         $use_win32"
	echo "  OS2:           $use_os2"
	echo "  PostScript:    $use_ps"
	echo "  PDF:           $use_pdf"
	echo "  SVG:           $use_svg"
	echo "  glitz:         $use_glitz"
	echo "  BeOS:          $use_beos"
	echo "  DirectFB:      $use_directfb"
	echo ""
	echo "the following font backends:"
	echo "  User:          yes (always builtin)"
	echo "  FreeType:      $use_ft"
	echo "  Win32:         $use_win32_font"
	echo "  Quartz:        $use_quartz_font"
	echo ""
	echo "the following features:"
	echo "  PNG functions: $use_png"
	echo ""
	echo "and the following debug options:"
	echo "  gcov support:  $use_gcov"
	echo "  test surfaces: $use_test_surfaces"
	echo "  ps testing:    $test_ps"
	echo "  pdf testing:   $test_pdf"
	echo "  svg testing:   $test_svg"
	if test x"$use_win32" = "xyes"; then
		echo "  win32 printing testing:    $test_win32_printing"
	fi
	echo ""

	if test x"$use_ft"          != "xyes" && \
	   test x"$use_win32_font"  != "xyes" && \
	   test x"$use_quartz_font" != "xyes" ; then

	   AC_MSG_ERROR([Cairo requires at least one font backend.
			  Please install freetype and fontconfig, then try again:
			  http://freetype.org/	http://fontconfig.org/
			])
	fi
	echo "$CAIRO_WARNING_MESSAGE"
])

